= CIP2015-06-16 - Public Type System and Type Annotations
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Stefan Plantikow <stefan.plantikow@neotechnology.com>
*Author:* Nigel Small <nigel.small@neotechnology.com>

[abstract]
.Abstract

This CIP specifies the public part of the type system of Cypher and introduces literal syntax for writing down types as well as new syntax for type annotations. The proposed type annotation syntax does not change the Cypher grammar right now but rather is intended as a template to be used by future CIPs. This CIP also informatively discusses future syntax that might use the introduced literal type syntax.

toc::[]

== Introduction

=== Background and Motivation

Cypher today has an undocumented internal type system.
In the interest of Cypher standardization and to enable multiple semantically consistent implementations, it is necessary to specify and document that type system.
Note that this is primarily an exercise of consolidation rather than exploration of the broadest type system we could support.

Furthermore, in order to support currently ongoing work for allowing users to define _stored procedures_, it has become necessary to specify types explicitly within signatures.
This will help with the following:

* In any interaction with an external language, type mapping between the external language and Cypher is necessary.
Any such type mapping must rest on a well defined type system for Cypher in order to be consistent across different implementations.
This applies to interaction via an external language supported by the implementation, as well as interaction via a remote protocol.
* To call user defined procedures from within a larger Cypher query the planner needs to know static type signatures in order to generate efficient plans.
* Statically typed signatures enable implementations to detect possible type errors at query compilation time.
* Statically typed signatures also allow us to add support for procedure overloading in the future.

To support these goals, it is necessary to at least introduce syntax for all valid, supported public types as well as syntax for type annotation.

=== Overview
For the purposes of this CIP, a type system is a system of classifying expressions according to what kinds of values they may evaluate to during the execution of a Cypher query.
It does *not *include a specification of a type inferencing and checking algorithm for Cypher queries.

Cypher today has a rich type system that unifies Java implementation types into a coherent type hierarchy and an accompanying type checker that supports rich types with https://en.wikipedia.org/wiki/TypeParameter[type parameters] and https://en.wikipedia.org/wiki/Union_type[union types].
So far it has not been possible to explicitly specify the type of an expression in a query.

This CIP proposes to introduce syntax for type literals and for type annotations for public types.
Any implementation may choose to incorporate a set of internal types beyond those specified here.
All such internal types must map cleanly onto the public type system and should generally not be made visible to end users.
The details of internal types are out of scope for the purposes of this document.

== Proposal

=== Types and Type Literal Syntax

The sections below list all types available at the time of acceptance of this CIP.

==== Core Types

The following should available from any implementation of Cypher

 * `Any`
 ** Parent of all types
 * `Number`
 ** Parent of all numeric types (i.e. `Integer` and `Float`)
 * `Boolean`
 ** true and false
 * `Integer`
 ** Exact numbers without decimals, i.e. -3, 0, 4
 * `Float`
 ** IEEE-754 64-bit floating point numbers
 * `Map`
 ** Maps to values of any type, i.e. { name: "Svensson" }. Note that keys are identifiers, not strings.
 ** This is also the supertype for `Node` and `Relationship`
 * `List<T>`
 ** Lists (ordered sequences with random access) of a given type T
 ** `List<T1>`` is a subtype of `List<T2>`` if `T1` is a subtype of `T2`. This works since values in Cypher are immutable. Adding an element of type `T` to a `List<S>`` would produce a new list of type `List<R>``, where `R` is the nearest common supertype of `T` and `S`
 * `Node`
 ** A self-contained copy of a graph node containing an identity, a set of textual labels and a set of properties
 * `String`
 ** Unicode Strings, i.e. `"Cypher"`, and `‘text’`
 * `Relationship`
 ** A self-contained copy of a graph relationship that connects two nodes and contains an identity, a textual type and a set of properties
 * `Path`
 ** A sequence of alternating nodes and relationships

=== Date and Time Types

The following should available from any implementation of Cypher in accordance with _CIP2015-08-06 - Date and Time_.

 * `DateTime`
 ** An instant capturing the date, the time, and the timezone.
 * `LocalDateTime`
 ** An instant capturing the date and the time, but not the time zone.
 * `Date`
 ** An instant capturing the date, but not the time, nor the time zone.
 * `LocalDate`
 ** An instant capturing the date, but not the time, nor the time zone.
 * `LocalTime`
 ** An instant capturing the time of day, but not the date, nor the time zone.
 * `Duration`
 ** A temporal amount. This captures the difference in time between two instants. It only captures the amount of time between two instants, it does not capture a start time and end time. A unit capturing the start time and end time would be a _Time Interval_ and is out of scope for this proposal.

=== Reserved type names

In addition to the types above, the following type names are reserved by this CIP for future use:

 * `Bytes`
 * `Identity`
 * `Point`

=== Nullability

TODO: DECIDE ON WHERE TO PUT "?"

The type system also provides a way to track nullability, i.e. a type may express if a given expression may be `NULL` or not:

* Non-nullable types are all types that do not permit `NULL` as a valid result of evaluating the underlying expression.
  All types specified above are non-nullable types.
* Nullable types are all types that permit `NULL` as a valid result of evaluating the underlying expression.
  Nullable types are formed by prefixing/suffixing a non-nullable type with a question mark.

Note that `NULL` is not a type but a value that inhabits every nullable type.

==== Type Annotation

To specify the type type of a term term in future changes to the Cypher grammar, this CIP proposes using the following syntax

[source, ebnf]
----
    term :: type
----

==== Type Literal Use Outside of Annotations

Type literals could be used in other production rules as well where this is considered more readable by future CIPs (e.g. a type test operator expr IS NUMBER).

=== Syntax

[source, ebnf]
----
type = scalar type
     | container type
     | optional type
     ;

optional type = "?", type;

scalar type   = "Any"
              | "Boolean"
              | "Integer"
              | "Float"
              | "Map"
              | "Node"
              | "String"
              | "Relationship"
              | "Path"
              | "Number"
              | "DateTime"
              | "LocalDateTime"
              | "Date"
              | "LocalDate"
              | "LocalTime"
              | "Duration"
              ;

container type = "LIST", "<", type, ">";

type annotation = term, "::", type ;
----

=== Semantics
This CIP only provides syntax for future CIPs, it does not directly change Cypher and therefore does not change semantics.

The intended use of type annotations is that they express that the annotated term either has, evaluates to, or is coerced to a value of the annotated type.

=== Interaction with existing features
This CIP adds new keywords for all type names.
It is expected that these type name keywords are only valid in specific contexts in the grammar (mostly in type annotations but also possibly in operators).
The likelihood of conflict with existing (or future) production rules is therefore minimal.

=== Alternatives

==== Type Literal Syntax
As part of writing this CIP, many syntax alternatives have been considered for type literal syntax:

* Alternative name for the `STRING` type: `TEXT`, `UNICODE`, `LIST<CHAR>`
* Alternative name for the `LIST` type: `ARRAY`, `COLLECTION`, `SEQUENCE`, `VECTOR`
* Alternative syntax for type parameters: `LIST OF T`, `LIST[T]`, `LIST<T>`, `LIST T`
* Alternative syntax for type annotations: `(STRING) expr`, `STRING expr`, `expr: `T`

=== Type Annotation Syntax


== What others do

=== SQL
SQL column types are given after the name of the column with no extra punctuation. For example:

[source,sql]
----
id INTEGER
name VARCHAR(40)
----

The SQL standard has adopted the following syntax for casting or converting values:

	   CAST ( <expr> AS <type> )

There are some variations in how different implementations support casting. This is detailed below.

==== PostgreSQL
Casting in PostgreSQL can be achieved by using cast functions in addition to the AS keyword:

[source,sql]
----
CREATE CAST (source_type AS target_type)
	WITH FUNCTION function_name (argument_type [, ...])
	[ AS ASSIGNMENT | AS IMPLICIT ]

SELECT CAST(42 AS float8);
----

==== MSSQL
MSSQL uses a similar notation to PostgreSQL for casting:

      CAST ( expression AS data_type [ ( length ) ] )

In addition, similar CONVERT and PARSE functions exist:

[source,sql]
----
CONVERT ( data_type [ ( length ) ] , expression [ , style ] )
PARSE ( string_value AS data_type [ USING culture ] )
----

Function type annotations use a similar syntax to column definitions:

     CREATE FUNCTION [dbo].[foo] ( @myNumber INTEGER )

=== SPARQL
SPARQL is based on the type system from RDF and XML schema and provides functionality for type testing and conversion.
It also supports annotating strings with a language.

 * Use in casts: `FILTER(xsd:integer(?time) > 1291908000)`
 * Use in type tests: `FILTER (datatype(?o)=xsd:datetime)`
 * Use in triplet data: `<subject> <predicate> "42"^^xsd:integer .`
 * Use in literals: `"42"^^http://www.w3.org/2001/XMLSchema#integer`
 * Language annotated text: `"cat"@en`

== Benefits to this proposal

* Explicit type syntax allows us to specify the types of arguments and return values in signatures of user defined procedures
* With further extensions it would enable users of Cypher to be more explicit about the types of values which is beneficial for error reporting, planning, performance, and query readability
* This allows clear requirements to be defined for serialization, particularly with respect to network protocols

== Caveats to this proposal

Adding explicit syntax for types may lead to a more complex and difficult to learn language.
Since the initial use of type syntax is for specifying the signatures of user defined procedures only, this should not be a strong concern.

== Audience Consultation

Communication with external stakeholders should happen as part of the consultation process for _CIP2015-06-24 Managing Procedures_.

== References

* Wikipedia on _type systems_
* CypherType and symbols package object in the Neo4j implementation
* SPARQL and SQL standards

== Appendix

This appendix captures the discussion around type syntax that was part of creating this CIP. It is informative only and not part of the proposal.
It merely documents the authors' ideas for future use of types in Cypher.

=== Internal vs public types
We distinguish between internal types and public types to minimize mental overhead and simplify language mapping.
Internal types are tracked by the type checking algorithm.
They may contain more sophisticated static analysis information such as nullability, which properties exist on a node, or alternative types for a value (union types).
A Cypher user commonly should not be required to be aware of internal types though they may influence behaviour or become visible in error messages.
Public types contain less information than internal types.
They can be specified in type annotations and there should exist straightforward mappings between the public type system and type systems of target languages of officially supported drivers and the store.

The diagram below gives an overview on the various concepts around the Cypher type system and how they relate to each other as seen by this CIP.

image:CIP2015-09-16-public-type-system-overview.png[Public Type System Overview]

=== Type mapping
The issue of mapping types from the public type system to other type systems (such as Java, JavaScript or PackStream) is not the concern of this document.
While still requiring clear definition, such mapping definitions are not a Cypher language concern.

=== Type aliases
Some of the type names are very long and thus could be somewhat difficult to type, and perhaps even read in longer function signatures.
Introducing a set of predefined and perhaps user defined type aliases, such as REL for RELATIONSHIP might be a remedy to this issue.

=== Possible future use of type syntax

==== Type annotations in declarations and definitions
It may be helpful to extend definitions that introduce new identifiers (WITH, RETURN) or signatures in procedure declarations with type annotations for improved type checking, planning, and possibly code generation.

*Example*
`RETURN expr AS a :: NUMBER`

==== Type ascription ("safe upcast")
A type ascription annotates an expression with a type such that casting the value at runtime to the given type cannot fail.
This may be useful (and in fact is used by Scala for example) to control what types are inferred by a type inferencing algorithm during semantic checking.

*Example*
`RETURN [1.0, 2.3, 3.0] :: LIST<NUMBER>`

==== Type cast ("unsafe downcast")
Beyond type ascription, a type cast asserts a specific type for an expression such that it cannot be verified at compile time if evaluating that expression will always produce a value of the target type.
Hence type casts may fail at runtime.

*Example*
`RETURN CAST n.prop :: NUMBER`

==== Type tests
Additionally it may be practical to test the type of a value at runtime.

*Example*
`RETURN n.prop IS [NOT] NUMBER`

==== Union Type Support
Cypher's current type checker tracks sets of possible types for expressions.
This could be understood as a form of union typing.
Union types do not map easily to the type systems of most common target languages (Java, Javascript, ...), they complicate type checking, and are not required for the work on remoting.
This is why they have not been included in this proposal.
They could be added instead at a later stage.

*Example*
`RETURN [1, "Yo"] :: LIST<STRING> | LIST<NUMBER>`
