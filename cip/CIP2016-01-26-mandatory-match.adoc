MANDATORY MATCH (u:User {id: {userId}})
= CIP2016-01-26 - Mandatory Match
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP proposes adding a new variant of the `MATCH` clause called `MANDATORY MATCH` that fails when it does not match at least a single row in the underlying graph.
--

toc::[]

== Motivation

When writing applications using Cypher, many queries will start off by looking up multiple individual nodes based on an unique id with the implied expectation of matching exactly one node. When that expectation is not fulfilled (either due to sending a wrong id or the node having been deleted) it becomes important to identify which lookup failed. Achieving  this currently is not well supported by Cypher.

== Background

The idea for this CIP grew out of a (now abandoned) dog fooding project for storing benchmarking information in Neo4j.

== Proposal

This CIP suggests the introduction of a new clause called `MANDATORY MATCH` that has the same basic form as the existing `MATCH` clause (i.e. `MANDATORY MATCH <pattern> [WHERE <predicate>]`).

If matching the graph pattern described by `MANDATORY MATCH` fails to match at least a single row, the execution of the while Cypher query fails with a descriptive error message that points to which `MANDATORY MATCH` clause failed and
includes all bound identifiers and parameters used in trying to match the described graph pattern.

=== Example

Find some nodes for which uniqueness constraints have been created up-front:

[source, cypher]
----
MANDATORY MATCH (u:User {id: {userId}})
MANDATORY MATCH (p:Product {id: {productId}})
RETURN (u)-[:OWNS]->(p)
----

=== Syntax

[source, ebnf]
----
clause  = "MANDATORY", "MATCH", pattern, [ { ",", pattern } ], [ "WHERE", predicate ]
        | ...
        ;
----

=== Interaction with existing features

It is an error to try to combine `MANDATORY` and `OPTIONAL` in the same `MATCH` clause.

=== Alternatives

If Cypher would provide a means for a user to raise errors that may be a more heavyweight mechanism to achieve the same goal.

== What others do

No similar facility exists in SQL.

== Benefits to this proposal

Application programmers get a new powerful facility for detecting semantical errors in their applications while
also failing early in the case of an error (thus avoiding unnecessary work).

== Caveats to this proposal

It increases the size of the language, if only slightly, and adds another key word.
