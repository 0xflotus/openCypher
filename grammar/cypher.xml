<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE grammar [
  <!ENTITY WS "<non-terminal ref='WS'/>">
  <!ENTITY SP "<non-terminal ref='SP'/>">
  <!ENTITY expr "<non-terminal ref='Expression'/>">
  <!ENTITY var "<non-terminal ref='Variable'/>">
  <!ENTITY TODO "<non-terminal ref='TODO'/>">
]>
<grammar language="Cypher" case-sensitive="false"
  xmlns="http://thobe.org/grammar"
  xmlns:rr="http://thobe.org/railroad"
  xmlns:ast="http://thobe.org/syntaxtree"
  xmlns:gen="http://thobe.org/stringgeneration">

  <production name="Cypher">
    &WS;
    <non-terminal ref="AllOptions"/>
    &WS;
    <non-terminal ref="Statements"/>
  </production>


  <vocabulary file="pre-parser.xml"/>


  <!-- / STATEMENTS \ -->

  <production name="Statements">
    &WS;<non-terminal ref="Statement"/>&WS;
    <repeat>
      ;
      &WS;<non-terminal ref="Statement"/>&WS;
    </repeat>
    <opt>;</opt>
  </production>

  <production name="Statement">
    <alt>
      <non-terminal ref="Command"/>
      <non-terminal ref="Query"/>
    </alt>
  </production>

  <production name="Command">
    <alt>
      <non-terminal ref="CreateUniqueConstraint"/>
      <non-terminal ref="CreateNodePropertyExistenceConstraint"/>
      <non-terminal ref="CreateRelationshipPropertyExistenceConstraint"/>
      <non-terminal ref="CreateIndex"/>
      <non-terminal ref="DropUniqueConstraint"/>
      <non-terminal ref="DropNodePropertyExistenceConstraint"/>
      <non-terminal ref="DropRelationshipPropertyExistenceConstraint"/>
      <non-terminal ref="DropIndex"/>
    </alt>
  </production>

  <production name="Query">
    <alt>
      <non-terminal ref="RegularQuery"/>
      <non-terminal ref="BulkImportQuery"/>
    </alt>
  </production>

  <production name="RegularQuery">
    <non-terminal ref="SingleQuery"/>
    <repeat>&WS;<non-terminal ref="Union"/></repeat>
  </production>

  <production name="BulkImportQuery">
    <non-terminal ref="PeriodicCommitHint"/>
    &WS;
    <non-terminal ref="LoadCSVQuery"/>
  </production>

  <production name="SingleQuery">
    <repeat min="1"><non-terminal ref="Clause"/></repeat>
  </production>

  <production name="PeriodicCommitHint">
    USING &SP; PERIODIC &SP; COMMIT
    <opt>&SP;<non-terminal ref="SignedIntegerLiteral"/></opt>
  </production>

  <production name="LoadCSVQuery">
    <non-terminal ref="LoadCSV"/>
    <repeat>&WS;<non-terminal ref="Clause"/></repeat>
  </production>

  <production name="Union">
    <alt>
      <seq>UNION &SP; ALL <non-terminal ref="SingleQuery"/></seq>
      <seq>UNION <non-terminal ref="SingleQuery"/></seq>
    </alt>
  </production>

  <production name="Clause">
    <alt>
      <non-terminal ref="LoadCSV"/>
      <non-terminal ref="Start"/>
      <non-terminal ref="Match"/>
      <non-terminal ref="Unwind"/>
      <non-terminal ref="Merge"/>
      <non-terminal ref="Create"/>
      <non-terminal ref="SetClause"/>
      <non-terminal ref="Delete"/>
      <non-terminal ref="Remove"/>
      <non-terminal ref="Foreach"/>
      <non-terminal ref="With"/>
      <non-terminal ref="Return"/>
      <non-terminal ref="Pragma"/>
    </alt>
  </production>

  <!-- \ STATEMENTS / -->


  <!-- / COMMANDS \ -->

  <production name="TODO"/>

  <production name="CreateUniqueConstraint">
    &TODO;
  </production>

  <production name="CreateNodePropertyExistenceConstraint">
    &TODO;
  </production>

  <production name="CreateRelationshipPropertyExistenceConstraint">
    &TODO;
  </production>

  <production name="CreateIndex">
    &TODO;
  </production>

  <production name="DropUniqueConstraint">
    &TODO;
  </production>

  <production name="DropNodePropertyExistenceConstraint">
    &TODO;
  </production>

  <production name="DropRelationshipPropertyExistenceConstraint">
    &TODO;
  </production>

  <production name="DropIndex">
    &TODO;
  </production>

  <!-- \ COMMANDS / -->


  <!-- / CLAUSES \ -->

  <production name="LoadCSV">
    LOAD &SP; CSV &SP;
    <opt>WITH &SP; HEADERS &SP;</opt>
    FROM &SP; &expr; &SP;
    AS &var; &SP;
    <opt>FIELDTERMINATOR &SP; <non-terminal ref="StringLiteral"/></opt>
  </production>

  <production name="Start">
    START &SP;
    <non-terminal ref="StartPoint"/>
    <repeat>&WS;,&WS;<non-terminal ref="StartPoint"/></repeat>
    <opt><non-terminal ref="Where"/></opt>
  </production>

  <production name="Match">
    <opt>OPTIONAL &SP;</opt>MATCH &SP;
    <non-terminal ref="Pattern"/>
    <repeat><non-terminal ref="Hint"/></repeat>
    <opt><non-terminal ref="Where"/></opt>
  </production>

  <production name="Unwind">
    UNWIND &SP; &expr; &SP; AS &SP; &var;
  </production>

  <production name="Merge">
    MERGE &SP; <non-terminal ref="PatternPart"/>
    <repeat>
      &SP; <non-terminal ref="MergeAction"/>
    </repeat>
  </production>

  <production name="MergeAction">
    <alt>
      <seq>ON &SP; MATCH &SP; <non-terminal ref="SetClause"/></seq>
      <seq>ON &SP; CREATE &SP; <non-terminal ref="SetClause"/></seq>
    </alt>
  </production>

  <production name="Create">
    <alt>
      <seq>CREATE UNIQUE &SP; <non-terminal ref="Pattern"/></seq>
      <seq>CREATE &SP; <non-terminal ref="Pattern"/></seq>
    </alt>
  </production>

  <production name="SetClause">
    SET <non-terminal ref="SetItem"/>
    <repeat>
      , <non-terminal ref="SetItem"/>
    </repeat>
  </production>


  <production name="SetItem">
    <alt>
      <seq><non-terminal ref="PropertyExpression"/> = &expr;</seq>
      <seq>&var; = &expr;</seq>
      <seq>&var; += &expr;</seq>
      <seq>&var;<non-terminal ref="NodeLabels"/></seq>
    </alt>
  </production>

  <production name="PropertyExpression">
    <non-terminal ref="Expression1"/>
    <repeat min="1">&WS;<non-terminal ref="PropertyLookup"/></repeat>
  </production>

  <production name="Delete">
    <alt>
      <seq>DELETE &expr;<repeat>, &expr;</repeat></seq>
      <seq>DETACH &SP; DELETE &expr;<repeat>, &expr;</repeat></seq>
    </alt>
  </production>

  <production name="Remove">
    REMOVE &SP; <non-terminal ref="RemoveItem"/>
    <repeat>&WS;,&WS;<non-terminal ref="RemoveItem"/></repeat>
  </production>

  <production name="RemoveItem">
    <alt>
      <seq>&var;<non-terminal ref="NodeLabels"/></seq>
      <non-terminal ref="PropertyExpression"/>
    </alt>
  </production>

  <production name="Foreach">
    FOREACH &WS; ( &WS; &var; &SP; IN &SP; &expr; | <repeat min="1">&SP;<non-terminal ref="Clause"/></repeat> &WS; )
  </production>

  <production name="With">
    <alt>
      <seq>WITH DISTINCT
        <non-terminal ref="ReturnBody"/>
        <opt><non-terminal ref="Where"/></opt>
      </seq>
      <seq>WITH
        <non-terminal ref="ReturnBody"/>
        <opt><non-terminal ref="Where"/></opt>
      </seq>
    </alt>
  </production>

  <production name="Return">
    <alt>
      <seq>RETURN DISTINCT <non-terminal ref="ReturnBody"/></seq>
      <seq>RETURN <non-terminal ref="ReturnBody"/></seq>
    </alt>
  </production>

  <production name="ReturnBody">
    <non-terminal ref="ReturnItems"/>
    <opt><non-terminal ref="Order"/></opt>
    <opt><non-terminal ref="Skip"/></opt>
    <opt><non-terminal ref="Limit"/></opt>
  </production>

  <production name="ReturnItems">
    <alt>
      <seq>*<repeat>,<non-terminal ref="ReturnItem"/></repeat></seq>
      <seq>
        <non-terminal ref="ReturnItem"/>
        <repeat>,<non-terminal ref="ReturnItem"/></repeat>
      </seq>
    </alt>
  </production>

  <production name="ReturnItem">
    <alt> <seq>&expr; AS &var;</seq> &expr; </alt>
  </production>


  <production name="Order">
    ORDER BY <non-terminal ref="SortItem"/>
    <repeat> , <non-terminal ref="SortItem"/></repeat>
  </production>

  <production name="Skip">
    SKIP &expr;
  </production>

  <production name="Limit">
    LIMIT &expr;
  </production>

  <production name="SortItem">
    <alt>
      <seq>&expr;<alt>DESCENDING DESC</alt></seq>
      <seq>&expr;<opt><alt>ASCENDING ASC</alt></opt></seq>
    </alt>
  </production>

  <production name="Pragma">
    _PRAGMA
    <alt>
      <seq>
        WITH NONE
        <opt><non-terminal ref="Skip"/></opt>
        <opt><non-terminal ref="Limit"/></opt>
        <opt><non-terminal ref="Where"/></opt>
      </seq>
      <seq>
        WITHOUT &var; <repeat> , &var;</repeat>
      </seq>
    </alt>
  </production>

  <production name="Hint">
    <alt>
      <seq>USING &SP; INDEX &SP; &var; <non-terminal ref="NodeLabel"/>(<non-terminal ref="PropertyKeyName"/>)</seq>
      <seq>USING &SP; JOIN &SP; ON &SP; &var; <repeat>&WS;,&WS;&var;</repeat></seq>
      <seq>USING &SP; SCAN &SP; &var; <non-terminal ref="NodeLabel"/></seq>
    </alt>
  </production>

  <!-- \ CLAUSES / -->


  <!-- / START \ -->

  <production name="StartPoint">
    &var; &WS; = &WS; <non-terminal ref="Lookup"/>
  </production>

  <production name="Lookup">
    <alt>
      <non-terminal ref="NodeLookup"/>
      <non-terminal ref="RelationshipLookup"/>
    </alt>
  </production>

  <production name="NodeLookup">
    NODE
    <alt>
      <non-terminal ref="IdentifiedIndexLookup"/>
      <non-terminal ref="IndexQuery"/>
      <non-terminal ref="IdLookup"/>
    </alt>
  </production>

  <production name="RelationshipLookup">
    <alt>RELATIONSHIP REL</alt>
    <alt>
      <non-terminal ref="IdentifiedIndexLookup"/>
      <non-terminal ref="IndexQuery"/>
      <non-terminal ref="IdLookup"/>
    </alt>
  </production>

  <production name="IdentifiedIndexLookup">
    : <non-terminal ref="SymbolicNameString"/>
    ( <non-terminal ref="SymbolicNameString"/> =
    <alt>
      <non-terminal ref="StringLiteral"/>
      <non-terminal ref="Parameter"/>
    </alt>)
  </production>

  <production name="IndexQuery">
    : <non-terminal ref="SymbolicNameString"/>
    (<alt>
      <non-terminal ref="StringLiteral"/>
      <non-terminal ref="Parameter"/>
    </alt>)
  </production>

  <production name="IdLookup">
    (<alt>
      <non-terminal ref="LiteralIds"/>
      <non-terminal ref="Parameter"/>
      *
    </alt>)
  </production>

  <production name="LiteralIds">
    <non-terminal ref="UnsignedIntegerLiteral"/>
    <repeat>
      &WS;,&WS;<non-terminal ref="UnsignedIntegerLiteral"/>
    </repeat>
  </production>

  <!-- \ START / -->


  <vocabulary file="basic-grammar.xml"/>

</grammar>
